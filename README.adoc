= Sending a generic message

This solution demonstrates how to use the native .NET driver for RabbitMQ as well as the EasyNetQ driver to send a generic message with a variable payload over the wire.

The solution consist of 3 projects

* *publisher*: Contains code simulating a simple message publisher
* *consumer*: Contains code simulating a simple message consumer
* *common*: Contains all definitions used by publisher and consumer, such as messages, serializers & deserializers as well as publisher and consumer implementations

== The publisher

Each implementation of a publisher needs to implement the interface `IPublisher`. This makes it very easy for a client to publish messages, without knowing the details of the undelying message transport. The client, e.g. a microservice just calls:

[source]
--
publisher.Publish(message)
--

It is up to the operations team to decide which transport mechanism to use. Current implementations are

* by given queue name
* by given exchange name, where the type of exchange is `direct`

When using the latter, the routing key is the full name of the message's type which is published, i.e. `typeof(TMessage).FullName`

== The consumer

Each variant of consumer needs to implement the interface `IConsumer`. Any client/microservice then can simple register a callback with the consumer as follows:

[source]
--
consumer.Subscribe<GenericMessage>(msg =>
    {
        Console.WriteLine($" [x] Received wrapped message {msg.Message.Body}");
        // Simulate processing
        Thread.Sleep(rnd.Next(100, 2000));
    });
--

No knowledge about the undelying implementation is needed.

== An example: Using *EasyNetQ* with Queue Name

To use a sample of the EasyNetQ implementation for a named queue you can use the `docker-compose-queue.yml` file in this project. Have a look into this file to understand how it is configured via environment variables...

. To run the application first navigate to this solution folder and then execute:
+
[source]
--
docker-compose -f docker-compose-queue.yml up -d --build
--

. To view the logs generated by the publisher execute:
+
[source]
--
docker-compose -f docker-compose-queue.yml logs -f publisher
--

. Open another terminal window and navigate to this solution
. Follow the consumer with:
+
[source]
--
docker-compose -f docker-compose-queue.yml logs -f consumer
--

. In your browser navigate to http://localhost:15672 to use the Admin UI of Rabbit MQ and analyze what's going on.

. Tear down the application with:
+
[source]
--
docker-compose -f docker-compose-queue.yml down -v
--

== An example: Using *native RabbitMQ client* with Queue Name

To use a sample of the EasyNetQ implementation for a named queue you can use the `docker-compose-queue.yml` file in this project. Have a look into this file to understand how it is configured via environment variables...

. To run the application first navigate to this solution folder and then execute:
+
[source]
--
docker-compose -f docker-compose-queue-native.yml up -d --build
--

. To view the logs generated by the publisher execute:
+
[source]
--
docker-compose -f docker-compose-queue-native.yml logs -f publisher
--

. Open another terminal window and navigate to this solution
. Follow the consumer with:
+
[source]
--
docker-compose -f docker-compose-queue-native.yml logs -f consumer
--

. In your browser navigate to http://localhost:15672 to use the Admin UI of Rabbit MQ and analyze what's going on.

. Tear down the application with:
+
[source]
--
docker-compose -f docker-compose-queue-native.yml down -v
--


== An example: Using EasyNetQ with Exchange

To use a sample of the EasyNetQ implementation for a named exchange of type `direct` you can use the `docker-compose.yml` file in this project. Have a look into this file to understand how it is configured via environment variables...

. To run the application first navigate to this solution folder and then execute:
+
[source]
--
docker-compose up -d --build
--

. To view the logs generated by the publisher execute:
+
[source]
--
docker-compose logs -f publisher
--

. Open another terminal window and navigate to this solution
. Follow the consumer with:
+
[source]
--
docker-compose logs -f consumer
--

. In your browser navigate to http://localhost:15672 to use the Admin UI of Rabbit MQ and analyze what's going on.

. Tear down the application with:
+
[source]
--
docker-compose down -v
--


== An example: Using *native RabbitMQ client* with Exchange

To use a sample of the native Rabbit MQ client implementation for a named exchange of type `direct` you can use the `docker-compose-native.yml` file in this project. Have a look into this file to understand how it is configured via environment variables...

. To run the application first navigate to this solution folder and then execute:
+
[source]
--
docker-compose -f docker-compose-native.yml up -d --build
--

. To view the logs generated by the publisher execute:
+
[source]
--
docker-compose -f docker-compose-native.yml logs -f publisher
--

. Open another terminal window and navigate to this solution
. Follow the consumer with:
+
[source]
--
docker-compose -f docker-compose-native.yml logs -f consumer
--

. In your browser navigate to http://localhost:15672 to use the Admin UI of Rabbit MQ and analyze what's going on.

. Tear down the application with:
+
[source]
--
docker-compose -f docker-compose-native.yml down -v
--

